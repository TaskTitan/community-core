import { ref, reactive } from "vue";
import { handleGenerateClick as handleGenerateClickBase } from "@/views/_components/base/stream";
import {
  saveTool,
  deleteTool,
  fetchTools,
  getTool,
  importTool,
} from "./components/TopMenu/components/ToolActions/toolActionsApi";
import generateUUID from "@/views/_utils/generateUUID.js";
import { toKebabCase } from "@/views/_utils/stringFormatting.js";
import { API_CONFIG } from "@/tt.config.js";

const initialFormState = {
  title: "",
  instructions: "",
  icon: "custom",
  provider: "",
  model: "",
  customFields: {},
};

export function useToolPanel() {
  const selectedTool = ref(null);
  const formData = reactive({ ...initialFormState });
  const templates = ref([]);

  async function fetchTemplates() {
    try {
      const fetchedTemplates = await fetchTools();
      templates.value = fetchedTemplates;
    } catch (error) {
      console.error("Error fetching templates:", error);
    }
  }
  function handleGenerateClick(event) {
    handleGenerateClickBase(event);
  }
  function onFormUpdated(key, value) {
    if (formData[key] !== value) {
      console.log(key, value);
      if (key === "customFields") {
        formData.customFields = value;
      } else {
        formData[key] = value;
      }
    }
  }
  function onToolSelected(tool) {
    if (tool && tool.id) {
      selectedTool.value = tool;
      Object.assign(formData, initialFormState);
      formData.id = tool.id;
      formData.title = tool.title || "";
      formData.instructions = tool.parameters?.instructions || "";
      formData.provider = tool.parameters?.provider || "";
      formData.model = tool.parameters?.model || "";
      formData.icon = tool.icon || "custom";
      formData.isShareable = tool.isShareable || false;
      formData.customFields = {};
      if (tool.parameters) {
        for (const [key, value] of Object.entries(tool.parameters)) {
          if (!["instructions", "provider", "model"].includes(key)) {
            formData.customFields[key] = value;
          }
        }
      }
    } else if (tool && tool.toolId) {
      // This handles the case where onToolSelected is called after saving a tool
      getTool(tool.toolId)
        .then((fetchedTool) => {
          onToolSelected(fetchedTool);
        })
        .catch((error) => {
          console.error("Error fetching saved tool:", error);
        });
    } else if (tool === "create-new") {
      clearFields();
    } else {
      if (!formData.id) {
        clearFields();
      }
    }
  }
  function onToolGenerated(generatedTool) {
    function toTitleCase(str) {
      return str
        .split("-")
        .map(
          (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        )
        .join(" ");
    }

    const tool = {
      id: generateUUID(),
      title: generatedTool.name || "",
      icon: "custom",
      parameters: {
        instructions:
          generatedTool.fields.find((f) => f.name === "template-instructions")
            ?.value || "",
        provider: "", // You may want to set a default provider
        model: "", // You may want to set a default model
      },
    };

    // Map other fields to parameters with transformed names and values
    generatedTool.fields.forEach((field) => {
      if (!["template-name", "template-instructions"].includes(field.name)) {
        const transformedName = toTitleCase(field.name);
        tool.parameters[transformedName] = {
          type: field.type,
          value: field.value,
          label: transformedName,
        };
      }
    });

    onToolSelected(tool);
  }
  async function onToolSaved(savedTool) {
    selectedTool.value = savedTool;
  }
  function onToolDeleted() {
    selectedTool.value = null;
    clearFields();
  }
  function clearFields() {
    Object.assign(formData, initialFormState);
    formData.customFields = {};
    selectedTool.value = null;
  }
  async function saveFormDataToDB(isSharing = false) {
    try {
      const currentUserId = localStorage.getItem("userId");
  
      const toolData = {
        id: formData.id,
        title: formData.title,
        category: formData.category || "custom",
        type: toKebabCase(formData.title) || "custom",
        icon: formData.icon,
        description: "This is a custom tool built by a user in the Tool Forge.",
        parameters: {
          instructions: formData.instructions,
          provider: formData.provider,
          model: formData.model,
          ...formData.customFields,
        },
        outputs: {
          generatedText: {
            type: "string",
            description: "The text generated by the LLM",
          },
          tokenCount: {
            type: "integer",
            description: "The number of tokens in the generated text",
          },
          error: {
            type: "string",
            description: "Error message if the LLM call failed",
          },
        },
        createdBy: currentUserId,
        isShareable: formData.isShareable,
      };
  
      // Always save to the base URL first
      const savedTool = await saveTool(toolData, API_CONFIG.BASE_URL);
  
      if (savedTool && savedTool.id) {
        formData.id = savedTool.id;
        toolData.id = savedTool.id; // Ensure the ID is set for remote saving
  
        // Show alert for saving to local database
        alert("Tool saved to local database successfully!");
  
        // If sharing, update isShareable and save to the remote URL
        if (isSharing === true) {
          toolData.isShareable = true;
          formData.isShareable = true;
          await saveTool(toolData, API_CONFIG.REMOTE_URL);
          alert("Tool shared to remote database successfully!");
        }
  
        return { id: savedTool.id, isShareable: formData.isShareable };
      } else {
        throw new Error("Invalid response from server");
      }
    } catch (error) {
      console.error("Error saving/updating tool:", error);
      alert("Failed to save/update tool. Please try again.");
      throw error;
    }
  }
  async function confirmDelete() {
    if (confirm("Are you sure you want to delete this tool?")) {
      if (selectedTool.value) {
        try {
          await deleteTool(selectedTool.value.id);
          onToolDeleted();
          await fetchTemplates();
        } catch (error) {
          console.error("Error deleting tool:", error);
        }
      }
    }
  }
  async function importTemplate() {
    const toolId = prompt("Please enter the tool ID you want to import:");
    if (toolId) {
      try {
        const importedTool = await importTool(toolId);
        if (importedTool) {
          onToolSelected(importedTool);
          alert("Tool imported successfully!");
        } else {
          alert("No tool found with the given ID.");
        }
      } catch (error) {
        console.error("Error importing tool:", error);
        if (error.message.includes("403")) {
          alert(
            "You don't have permission to access this tool. It might not be shared."
          );
        } else {
          alert("Failed to import tool. Please check the ID and try again.");
        }
      }
    }
  }
  async function shareTemplate() {
    if (formData.id) {
      try {
        const result = await saveFormDataToDB(true);
        if (result && result.id) {
          await navigator.clipboard.writeText(result.id);
          alert(
            `Tool is now shareable. The ID has been copied to your clipboard: ${result.id}`
          );
        }
      } catch (err) {
        console.error("Failed to share tool: ", err);
        alert("Failed to share tool. Please try again.");
      }
    } else {
      alert("No tool is selected or the tool does not exist.");
    }
  }
  async function loadToolById(toolId) {
    try {
      const tool = await getTool(toolId);
      if (tool) {
        onToolSelected(tool);
      } else {
        console.error("Tool not found");
        // You might want to show an error message to the user here
      }
    } catch (error) {
      console.error("Error loading tool by ID:", error);
      // You might want to show an error message to the user here
    }
  }

  return {
    selectedTool,
    formData,
    templates,
    handleGenerateClick,
    onFormUpdated,
    onToolSelected,
    onToolSaved,
    onToolDeleted,
    clearFields,
    saveFormDataToDB,
    confirmDelete,
    importTemplate,
    shareTemplate,
    onToolGenerated,
    fetchTemplates,
    loadToolById,
  };
}
